<!DOCTYPE html>
<html lang="en">
<head>
    <title>ed25519 / x25519</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta charset="utf-8">

    <script type="text/javascript" language="JavaScript" src="noble-curves.js"></script>

    <script>


  async function AESenc(data, password) {

    if(typeof data === 'string') data = new TextEncoder().encode(data);
    if(typeof password === 'string') password = new TextEncoder().encode(password);

    // Генерация ключа из пароля
    const keyMaterial = await crypto.subtle.importKey( 'raw', password, 'PBKDF2', false, ['deriveKey'] );
    // Генерация ключа шифрования AES-GCM
    const salt = crypto.getRandomValues(new Uint8Array(32)); // Случайная соль 16 заменил на 32
    const key = await crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-512' },
        keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt']
    );
    // Генерация случайного IV
    const iv = crypto.getRandomValues(new Uint8Array(12));
    // Шифрование
    const encrypted = await crypto.subtle.encrypt( { name: 'AES-GCM', iv }, key, data );
    // Возвращаем зашифрованные данные, соль и IV
    return { encrypted: new Uint8Array(encrypted), salt, iv };
  }

  async function AESdec(data, password, salt, iv) {
    if(typeof data === 'string') data = new TextEncoder().encode(data);
    if(typeof password === 'string') password = new TextEncoder().encode(password);

    // Генерация ключа из пароля
    const keyMaterial = await crypto.subtle.importKey( 'raw', password,'PBKDF2', false, ['deriveKey'] );
    // Восстановление ключа шифрования AES-GCM
    const key = await crypto.subtle.deriveKey(
	{ name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-512' }, // не ставить 200000: DOMException: The operation failed for an operation-specific reason
	keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['decrypt']
    );
    // Расшифровка
    const decrypted = await crypto.subtle.decrypt( { name: 'AES-GCM', iv }, key, data );
    return new Uint8Array(decrypted); // new TextDecoder().decode(decrypted);
  }

    function prn(txt, data) {
	    if(data instanceof Uint8Array) data = `(${data.length} bytes) <tt style='font-size:11px'>${nobleCurves.utils.bytesToHex(data)}</tt>`;
	    else if(data === true) data = `<font color='green'>true</font>`;
	    else if(data === false) data = `<font color='red'>false</font>`;
	    else if(typeof(data) === 'string') data = `<font color='blue'>${data}</font>`;

	    const s = typeof(data) === 'undefined'
		    ? `<div><big><b>${txt}</b></big></div>`
		    : `<div><u>${txt}</u>: ${data}</div>`
	    ;
	    const e = document.querySelector('#buka');
	    e.innerHTML = e.innerHTML + s;
    }

    async function TEST() {

	prn( 'Наши данные' );
	    const txt = "Hello, Ed25519 forever";
		prn( `txt`, txt );
            const message = new TextEncoder().encode(txt);
		prn( `txt HEX`, message );

	prn( 'Генерим пару ключей А (Edwards)' );
    	    const privateA = nobleCurves.ed25519.utils.randomPrivateKey();
		prn( 'privateA (edwards)', privateA );
            const publicA = nobleCurves.ed25519.getPublicKey(privateA);
		prn( 'publicA (edwards)', publicA );

	prn( 'Генерим пару ключей B (Edwards)' );
            const privateB = nobleCurves.ed25519.utils.randomPrivateKey();
		prn( 'privateB', privateB );
            const publicB = nobleCurves.ed25519.getPublicKey(privateB);
		prn( 'publicB', publicB );

	prn( 'ПОДПИСЬ. Подписываем данные ключом privateA' );
            const signatureA1 = nobleCurves.ed25519.sign(message, privateA);
		prn( 'signatureA1', signatureA1 );
		prn( 'Проверка подписи ключом publicA', nobleCurves.ed25519.verify(signatureA1, message, publicA) );

	prn( 'ШИФРОВАНИЕ. Сперва конвентируем формат Edwards в Montgomery' );
            const privateAm = nobleCurves.ed25519_edwardsToMontgomeryPriv(privateA);
		prn( 'privateAm (montgomery)', privateAm );
            const publicAm = nobleCurves.ed25519_edwardsToMontgomeryPub(publicA);
		prn( 'publicAm (montgomery)', publicAm );
            const privateBm = nobleCurves.ed25519_edwardsToMontgomeryPriv(privateB);
		prn( 'privateBm (montgomery)', privateBm );
            const publicBm = nobleCurves.ed25519_edwardsToMontgomeryPub(publicB);
		prn( 'publicBm (montgomery)', publicBm );

	prn( 'Генерация общих секретов x25519 для Montgomery' );
    	    const sharedAm = nobleCurves.x25519.getSharedSecret(privateAm, publicBm);
        	prn('A для B (privateAm, publicBm)', sharedAm);
    	    const sharedBm = nobleCurves.x25519.getSharedSecret(privateBm, publicAm);
        	prn('B для A (privateBm, publicAm)', sharedBm);
		prn('Совпадают ли', sharedAm.toString() === sharedBm.toString() );

	prn( 'Шифрование встроенным AES браузера' );
	    // const data = new Uint8Array([0x11, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x22 ]); // Бинарные данные
	    const data = txt;
		prn('data',data);
	    const { encrypted, salt, iv } = await AESenc(data, sharedAm);
		prn('iv',iv);
		prn('salt',salt);
		prn('encrypted',encrypted);
	    const decrypted = await AESdec(encrypted, sharedAm, salt, iv);
		prn('decrypted',decrypted);
		prn('decrypted',new TextDecoder().decode(decrypted) );

    }
    </script>
</head>
<body onload="TEST()">
    <h2>ed25519 / x25519</h2>
    <div id="buka"></div>
</body>
</html>
